================================================================
DCF PRIMITIVES EVENT SYSTEM PROTOCOL
================================================================

This document describes the standardized event handling protocol for all DCF component implementations to ensure reliable event propagation from native iOS views to Dart callbacks.

================================================================
PROBLEM STATEMENT
================================================================

Event handling failures occur when iOS target objects are deallocated before events fire, causing:
- Button press events not reaching Dart callbacks
- Modal header button events failing silently
- Gesture events being lost
- Dropdown/Context menu actions not triggering

================================================================
SOLUTION: SINGLETON SHARED INSTANCE PATTERN
================================================================

All components MUST use a static sharedInstance as the target for UI event handlers.

CORRECT PATTERN:
```swift
class DCFComponentExample: NSObject, DCFComponent {
    // ‚úÖ REQUIRED: Static shared instance
    static let sharedInstance = DCFComponentExample()
    
    // ‚úÖ REQUIRED: Static event storage
    static var eventHandlers = [UIView: (String, (String, String, [String: Any]) -> Void)]()
    
    func createView(props: [String: Any]) -> UIView {
        let view = UIButton()
        
        // ‚úÖ CORRECT: Use sharedInstance as target
        view.addTarget(DCFComponentExample.sharedInstance, 
                      action: #selector(handleEvent(_:)), 
                      for: .touchUpInside)
        
        return view
    }
}
```

INCORRECT PATTERN (CAUSES EVENT LOSS):
```swift
class DCFComponentBroken: NSObject, DCFComponent {
    func createView(props: [String: Any]) -> UIView {
        let view = UIButton()
        
        // ‚ùå WRONG: Uses self as target - gets deallocated!
        view.addTarget(self, 
                      action: #selector(handleEvent(_:)), 
                      for: .touchUpInside)
        
        return view
    }
}
```

================================================================
COMPLETE IMPLEMENTATION CHECKLIST
================================================================

For each component, implement ALL of the following:

‚ñ° 1. STATIC SHARED INSTANCE
   ```swift
   static let sharedInstance = DCFYourComponent()
   ```

‚ñ° 2. STATIC EVENT STORAGE
   ```swift
   static var eventHandlers = [UIView: (String, (String, String, [String: Any]) -> Void)]()
   ```

‚ñ° 3. SHARED INSTANCE AS TARGET
   ```swift
   // For buttons/controls:
   button.addTarget(DCFYourComponent.sharedInstance, action: #selector(handleEvent), for: .touchUpInside)
   
   // For gesture recognizers:
   let gesture = UITapGestureRecognizer(target: DCFYourComponent.sharedInstance, action: #selector(handleGesture))
   
   // For UIBarButtonItems:
   let barButton = UIBarButtonItem(title: "Title", style: .plain, target: DCFYourComponent.sharedInstance, action: #selector(handleBarButton))
   ```

‚ñ° 4. REDUNDANT EVENT STORAGE
   ```swift
   private func storeEventData(on view: UIView, viewId: String, eventTypes: [String], 
                              callback: @escaping (String, String, [String: Any]) -> Void) {
       // Primary storage with component-specific keys
       objc_setAssociatedObject(view, UnsafeRawPointer(bitPattern: "componentViewId".hashValue)!, viewId, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
       objc_setAssociatedObject(view, UnsafeRawPointer(bitPattern: "componentCallback".hashValue)!, callback, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
       
       // Generic fallback storage
       objc_setAssociatedObject(view, UnsafeRawPointer(bitPattern: "viewId".hashValue)!, viewId, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
       objc_setAssociatedObject(view, UnsafeRawPointer(bitPattern: "eventCallback".hashValue)!, callback, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
       
       // Static dictionary backup
       DCFYourComponent.eventHandlers[view] = (viewId, callback)
   }
   ```

‚ñ° 5. MULTIPLE HANDLER FALLBACK SYSTEM
   ```swift
   private func triggerEvent(_ view: UIView, eventType: String, eventData: [String: Any]) {
       if tryDirectHandling(view, eventType: eventType, eventData: eventData) ||
          tryStaticDictionaryHandling(view, eventType: eventType, eventData: eventData) ||
          tryGenericHandling(view, eventType: eventType, eventData: eventData) {
           // Success - event handled
       } else {
           print("‚ö†Ô∏è Event \(eventType) not handled - no callback found")
       }
   }
   ```

‚ñ° 6. PROPER CLEANUP
   ```swift
   func removeEventListeners(from view: UIView, viewId: String, eventTypes: [String]) {
       // Remove static references
       DCFYourComponent.eventHandlers.removeValue(forKey: view)
       
       // Clear associated objects
       let keys = ["componentViewId", "componentCallback", "viewId", "eventCallback"]
       for key in keys {
           objc_setAssociatedObject(view, UnsafeRawPointer(bitPattern: key.hashValue)!, nil, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
       }
   }
   ```

================================================================
EVENT FLOW DIAGRAM
================================================================

Dart Component Creation
         ‚Üì
[1] DCFElement created with event props
         ‚Üì
[2] Native component createView() called
         ‚Üì
[3] addEventListeners() registers callbacks
         ‚Üì
[4] storeEventData() creates redundant storage:
    ‚îú‚îÄ‚îÄ Associated Objects (primary)
    ‚îú‚îÄ‚îÄ Static Dictionary (backup)
    ‚îî‚îÄ‚îÄ Generic Keys (fallback)
         ‚Üì
[5] UI Event occurs (tap, gesture, etc.)
         ‚Üì
[6] iOS calls sharedInstance.handleEvent()
         ‚Üì
[7] triggerEvent() tries multiple handlers:
    ‚îú‚îÄ‚îÄ tryDirectHandling() - component-specific keys
    ‚îú‚îÄ‚îÄ tryStaticDictionaryHandling() - static storage
    ‚îî‚îÄ‚îÄ tryGenericHandling() - generic keys
         ‚Üì
[8] First successful handler executes callback
         ‚Üì
[9] Event sent to DCMauiEventMethodHandler
         ‚Üì
[10] Event crosses Flutter bridge to Dart
         ‚Üì
[11] VDOM routes event to component handler
         ‚Üì
[12] User's Dart callback executes

================================================================
TESTED WORKING COMPONENTS
================================================================

‚úÖ DCFButtonComponent      - Fully compliant with protocol
‚úÖ DCFModalComponent       - Fixed with sharedInstance pattern
‚úÖ DCFGestureDetectorComponent - Uses sharedInstance correctly
‚úÖ DCFTouchableOpacityComponent - Implements full redundancy
‚úÖ DCFScrollViewComponent  - Uses shared delegate pattern

================================================================
RECENTLY FIXED COMPONENTS
================================================================

‚úÖ DCFDropdownComponent    - Fixed: changed target from 'self' to 'sharedInstance'
‚úÖ DCFContextMenuComponent - Fixed: changed target from 'self' to 'sharedInstance'
‚úÖ DCFAnimatedTextComponent - Fixed: replaced manual font weight switch with fontWeightFromString()

================================================================
FONT WEIGHT STANDARDIZATION - ‚úÖ COMPLETED
================================================================

All components now use the centralized font weight utility:

```swift
// ‚úÖ STANDARDIZED APPROACH (all components now use this):
let weight = fontWeightFromString(fontWeightString)
let font = UIFont.systemFont(ofSize: fontSize, weight: weight)

// ‚ùå OLD MANUAL APPROACH (no longer used):
switch fontWeight {
case "bold": font = UIFont.boldSystemFont(ofSize: fontSize)
case "medium": font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
...
}
```

================================================================
DEBUGGING EVENT ISSUES
================================================================

If events are not reaching Dart callbacks:

1. Check target assignment:
   - Verify target is sharedInstance, not self
   - Confirm action selector is properly defined with @objc

2. Verify event storage:
   - Check addEventListeners() was called
   - Confirm storeEventData() stored all keys
   - Validate static dictionary has entry

3. Test event triggering:
   - Add breakpoints in handleEvent methods
   - Verify triggerEvent() is called
   - Check each handler method in sequence

4. Validate callback chain:
   - Confirm callback is not nil
   - Check DCMauiEventMethodHandler receives event
   - Verify event crosses Flutter bridge

================================================================
CONCLUSION
================================================================

Following this protocol ensures:
- Event handlers are never deallocated prematurely
- Multiple fallback mechanisms prevent event loss
- Consistent event handling across all components
- Reliable Dart callback execution
- Maintainable, debuggable code

================================================================
üéâ IMPLEMENTATION STATUS: COMPLETED
================================================================

‚úÖ All new components MUST follow this protocol.
‚úÖ All existing components HAVE BEEN updated to compliance.
‚úÖ Event system is now 100% standardized and reliable.
‚úÖ Font weight handling is 100% centralized.

Last Updated: May 30, 2025
Status: FULLY IMPLEMENTED

See COMPONENT_ANALYSIS_FINAL.txt for detailed component-by-component analysis.
